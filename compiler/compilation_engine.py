"""Compilation engine module of the compiler

Classes:
    CompilationEngine
"""

import sys

from constants import TerminalElement, TokenType
from enums.arithmetic_command import ArithmeticCommand
from enums.segment import Segment
from enums.symbol_table_field import SymbolTableField
from enums.variable_kind import VariableKind
from symbol_table import SymbolTable


class CompilationEngine:
    """CompilationEngine class of the Jack compiler.

    Emits a structured representation of the input source code
    wrapped in XML tags.

    Gets input from a Tokenizer and emits output to a file.
    Output is generated by a series of compile_xxx functions, each designed to
    handle the compilation of a specific Jack langugage construct xxx.
    Each compile_xxx function should get from the input, and handle,
    all the tokens that make up xxx, advance the Tokenizer exactly beyond these
    tokens, and output the parsing of xxx.

    Properties:
        input: input stream of tokens
        output: file object of the output
        symbol_tables: class level and subroutine level symbol tables
        classname: name of the class being compiled
        subroutine: name of the subroutine being compiled
        subroutine_num_vars: number of local variables in current subroutine

    Methods:
        compile_class() -> None
        compile_class_var_dec() -> None
        compile_subroutine() -> None
        compile_parameter_list() -> None
        compile_subroutine_body() -> None
        compile_var_dec() -> None
        compile_statements() -> None
        compile_let() -> None
        compile_if() -> None
        compile_while() -> None
        compile_do() -> None
        compile_return() -> None
        compile_expression_list() -> int
    """

    def __init__(self, tokenizer, vm_writer):
        self.input = tokenizer
        self.symbol_tables = {'class': SymbolTable(), 'subroutine': SymbolTable()}
        self.output = vm_writer
        self.classname = ''
        self.subroutine = ''
        self.subroutine_num_vars = 0

    def __del__(self):
        self.output.close()

    def _eat(self, token, identifier_category=None, declaration=False):
        self.input.advance()
        return

        # old code
        token_type = getattr(TerminalElement, self.input.token_type())

        if self.input.current_token != token:
            print(f'Invalid token: {token} is not {self.input.current_token}.')
            sys.exit(1)

        if self.input.token_type() == TokenType.STRING_CONST:
            token = token.strip('"')
        elif token == '<':
            token = '&lt;'
        elif token == '>':
            token = '&gt;'
        elif token == '&':
            token = '&amp;'

        if token_type == TerminalElement.IDENTIFIER:
            self.output.write('<identifier>\n')
            self.output.write(f'<name> {token} </name>\n')

            if identifier_category in ('class', 'subroutine'):
                self.output.write(f'<category> {identifier_category} </category>\n')
            else:
                # check which symbol table contains the variable
                if self.symbol_tables['subroutine'].index_of(token) >= 0:
                    level = 'subroutine'
                elif self.symbol_tables['class'].index_of(token) >= 0:
                    level = 'class'
                else:
                    level = None

                if level:
                    kind = self.symbol_tables[level].kind_of(token).name.lower()
                    self.output.write(f'<category> {kind} </category>\n')
                    self.output.write(
                        f'<index> {self.symbol_tables[level].index_of(token)} </index>\n'
                    )

            self.output.write(f'<usage> {"declared" if declaration else "used" } </usage>\n')
            self.output.write('</identifier>\n')
        else:
            self.output.write(f'<{token_type}> {token} </{token_type}>\n')

        self.input.advance()

    def compile_class(self):
        """Compile a complete class"""
        self._eat('class')
        self.classname = self.input.current_token
        self._eat(self.input.current_token)  # className
        self._eat('{')

        while self.input.current_token in ('static', 'field'):
            self.compile_class_var_dec()
        while self.input.current_token in ('constructor', 'function', 'method'):
            self.compile_subroutine()

        self._eat('}')

    def compile_class_var_dec(self):
        """Compile a static or field variable declaration"""
        var_props = {}  # data for populating the symbol table

        # variable kind
        if self.input.current_token == 'static':
            var_props[SymbolTableField.KIND] = VariableKind.STATIC
        else:
            var_props[SymbolTableField.KIND] = VariableKind.FIELD
        self._eat(self.input.current_token)  # 'static'|'field'

        # variable type
        var_props[SymbolTableField.TYPE] = self.input.current_token
        self._eat(self.input.current_token)  # type

        # variable name
        self.symbol_tables["class"].define(
            self.input.current_token,
            var_props[SymbolTableField.TYPE],
            var_props[SymbolTableField.KIND]
        )  # populate symbol table
        self._eat(self.input.current_token)  # varName

        # if a comma is present, that means there are more variables
        while self.input.current_token == ',':
            self._eat(',')
            self.symbol_tables["class"].define(
                self.input.current_token,
                var_props[SymbolTableField.TYPE],
                var_props[SymbolTableField.KIND]
            )  # populate symbol table
            self._eat(self.input.current_token)  # varName

        self._eat(';')

    def compile_subroutine(self):
        """Compile a complete method, function, or constructor"""
        # reset subroutine level symbol table
        self.symbol_tables['subroutine'].reset()
        # reset number of local variables
        self.subroutine_num_vars = 0

        self._eat(self.input.current_token)  # 'constructor'|'function'|'method'
        self._eat(self.input.current_token)  # 'void'|type
        self.subroutine = f'{self.classname}.{self.input.current_token}'
        self._eat(self.input.current_token)  # subroutineName
        self._eat('(')
        self.compile_parameter_list()
        self._eat(')')
        self.compile_subroutine_body()

    def compile_parameter_list(self):
        """Compile a (possibly empty) parameter list"""
        if self.input.current_token != ')':
            arg_type = self.input.current_token
            self._eat(self.input.current_token)  # type
            self.symbol_tables['subroutine'].define(
                self.input.current_token,
                arg_type,
                VariableKind.ARG
            )  # populate symbol table
            self._eat(self.input.current_token, declaration=True)  # varName

            # the presence of a comma means that there are more parameters
            while self.input.current_token == ',':
                self._eat(',')
                arg_type = self.input.current_token
                self._eat(self.input.current_token)  # type
                self.symbol_tables['subroutine'].define(
                    self.input.current_token,
                    arg_type,
                    VariableKind.ARG
                )  # populate symbol table
                self._eat(self.input.current_token, declaration=True)  # varName

    def compile_subroutine_body(self):
        """Compile a subroutine's body"""
        self._eat('{')
        while self.input.current_token == 'var':
            self.compile_var_dec()
        # generate function command after variable declarations are compiled
        self.output.write_function(self.subroutine, self.subroutine_num_vars)
        self.compile_statements()
        self._eat('}')

    def compile_var_dec(self):
        """Compile a variable declaration"""
        self._eat('var')
        var_type = self.input.current_token
        self._eat(self.input.current_token)  # type
        self.symbol_tables['subroutine'].define(
            self.input.current_token,
            var_type,
            VariableKind.VAR
        )  # populate symbol table
        self.subroutine_num_vars += 1  # increment local variable counter
        self._eat(self.input.current_token, declaration=True)  # varName

        # check for and compile more variable names
        while self.input.current_token == ',':
            self._eat(',')
            self.symbol_tables['subroutine'].define(
                self.input.current_token,
                var_type,
                VariableKind.VAR
            )  # populate symbol table
            self.subroutine_num_vars += 1  # increment local variable counter
            self._eat(self.input.current_token, declaration=True)  # varName

        self._eat(';')

    def compile_statements(self):
        """Compile a sequence of statements"""
        # self.output.write('<statements>\n')

        while self.input.current_token != '}':
            if self.input.current_token == 'let':
                self.compile_let()
            elif self.input.current_token == 'if':
                self.compile_if()
            elif self.input.current_token == 'while':
                self.compile_while()
            elif self.input.current_token == 'do':
                self.compile_do()
            elif self.input.current_token == 'return':
                self.compile_return()

        # self.output.write('</statements>\n')

    def compile_let(self):
        """Compile a let statement"""
        # self.output.write('<letStatement>\n')

        self._eat('let')
        self._eat(self.input.current_token)  # varName
        
        if self.input.current_token == '[':  # varName'['expression']'
            self._eat('[')
            self.compile_expression()
            self._eat(']')

        self._eat('=')
        self.compile_expression()
        self._eat(';')

        # self.output.write('</letStatement>\n')

    def compile_if(self):
        """Compile an if statement, possibly with a trailing else clause"""
        # self.output.write('<ifStatement>\n')

        self._eat('if')
        self._eat('(')
        self.compile_expression()
        self._eat(')')
        self._eat('{')
        self.compile_statements()
        self._eat('}')

        # handle optional else clause
        if self.input.current_token == 'else':
            self._eat('else')
            self._eat('{')
            self.compile_statements()
            self._eat('}')

        # self.output.write('</ifStatement>\n')

    def compile_while(self):
        """Compile a while statement"""
        # self.output.write('<whileStatement>\n')

        self._eat('while')
        self._eat('(')
        self.compile_expression()
        self._eat(')')
        self._eat('{')
        self.compile_statements()
        self._eat('}')

        # self.output.write('</whileStatement>\n')


    def compile_do(self):
        """Compile a do statement"""
        self._eat('do')
        self._compile_subroutine_call()
        # discard return value of void subroutine
        self.output.write_pop(Segment.TEMP, 0)
        self._eat(';')

    def compile_return(self):
        """Compile a return statement"""
        self._eat('return')
        if self.input.current_token != ';':
            self.compile_expression()
        else:
            self.output.write_push(Segment.CONSTANT, 0)
        self.output.write_return()
        self._eat(';')

    def compile_expression(self):
        """Compile an expression"""
        self.compile_term()  # term
        
        # (op term)
        while self.input.current_token in ('+', '-', '*', '/', '&', '|', '<', '>', '='):
            op = self.input.current_token  # remember operation to be performed postfix
            self._eat(self.input.current_token)
            self.compile_term()

            if op == '+':
                self.output.write_arithmetic(ArithmeticCommand.ADD)
            elif op == '-':
                self.output.write_arithmetic(ArithmeticCommand.SUB)
            elif op == '*':
                self.output.write_call('Math.multiply', 2)
            elif op == '/':
                self.output.write_call('Math.divide', 2)
            elif op == '&':
                self.output.write_arithmetic(ArithmeticCommand.AND)
            elif op == '|':
                self.output.write_arithmetic(ArithmeticCommand.OR)
            elif op == '<':
                self.output.write_arithmetic(ArithmeticCommand.LT)
            elif op == '>':
                self.output.write_arithmetic(ArithmeticCommand.GT)
            elif op == '=':
                self.output.write_arithmetic(ArithmeticCommand.EQ)

    def compile_term(self):
        """Compile a term"""
        # self.output.write('<term>\n')

        # (unaryOp term)
        if self.input.current_token in ('-', '~'):
            if self.input.current_token == '-':
                self.output.write_arithmetic(ArithmeticCommand.NEG)
            else:
                self.output.write_arithmetic(ArithmeticCommand.NOT)
            self._eat(self.input.current_token)
            self.compile_term()

        # '('expression')'
        elif self.input.current_token == '(':
            self._eat('(')
            self.compile_expression()
            self._eat(')')

        # integerConstant|stringConstant|keywordConstant|varName
        else:
            term = self.input.current_token
            self._eat(self.input.current_token)

            if self.input.current_token == '.':  # subroutineCall
                self._eat('.')
                self._compile_subroutine_call(term)
            elif self.input.current_token == '[':  # varName'['expression']'
                self._eat('[')
                self.compile_expression()
                self._eat(']')
            else:  # handle pushing term onto the stack
                if term.isdecimal():
                    self.output.write_push(Segment.CONSTANT, term)

        # self.output.write('</term>\n')

    def compile_expression_list(self):
        """Compile an (possibly empty) comma-separated list of expressions.
        Return the number of expressions in the list.
        """
        num_args = 0

        if self.input.current_token != ')':
            self.compile_expression()
            num_args += 1
        while self.input.current_token == ',':
            self._eat(',')
            self.compile_expression()
            num_args += 1

        return num_args

    def _compile_subroutine_call(self, call_on=None):
        """Compile a subroutine call"""
        num_args = 0

        # save subroutine name
        subroutine_name = (call_on + '.') if call_on else '' + self.input.current_token
        self._eat(self.input.current_token)

        if self.input.current_token == '.':
            self._eat('.')
            subroutine_name += f'.{self.input.current_token}'
            self._eat(self.input.current_token)  # varName

        if self.input.current_token == '(':
            self._eat('(')
            num_args = self.compile_expression_list()
            self._eat(')')

        self.output.write_call(subroutine_name, num_args)
