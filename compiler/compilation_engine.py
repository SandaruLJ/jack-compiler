"""Compilation engine module of the compiler

Classes:
    CompilationEngine
"""

import sys

from constants import TerminalElement, TokenType, keywords
from enums.arithmetic_command import ArithmeticCommand
from enums.segment import Segment
from enums.symbol_table_field import SymbolTableField
from enums.variable_kind import VariableKind
from symbol_table import SymbolTable


class CompilationEngine:
    """CompilationEngine class of the Jack compiler.

    Emits a structured representation of the input source code
    wrapped in XML tags.

    Gets input from a Tokenizer and emits output to a file.
    Output is generated by a series of compile_xxx functions, each designed to
    handle the compilation of a specific Jack langugage construct xxx.
    Each compile_xxx function should get from the input, and handle,
    all the tokens that make up xxx, advance the Tokenizer exactly beyond these
    tokens, and output the parsing of xxx.

    Properties:
        input: input stream of tokens
        output: file object of the output
        symbol_tables: class level and subroutine level symbol tables
        classname: name of the class being compiled
        subroutine: name of the subroutine being compiled
        subroutine_num_vars: number of local variables in current subroutine
        label_count: counter used for generating unique labels

    Methods:
        compile_class() -> None
        compile_class_var_dec() -> None
        compile_subroutine() -> None
        compile_parameter_list() -> None
        compile_subroutine_body() -> None
        compile_var_dec() -> None
        compile_statements() -> None
        compile_let() -> None
        compile_if() -> None
        compile_while() -> None
        compile_do() -> None
        compile_return() -> None
        compile_expression_list() -> int
    """

    def __init__(self, tokenizer, vm_writer):
        self.input = tokenizer
        self.symbol_tables = {'class': SymbolTable(), 'subroutine': SymbolTable()}
        self.output = vm_writer
        self.classname = ''
        self.subroutine = ''
        self.subroutine_num_vars = 0
        self.subroutine_type = ''
        self.label_count = 0

    def __del__(self):
        self.output.close()

    def _eat(self, token, identifier_category=None, declaration=False):
        self.input.advance()
        return

        # old code
        token_type = getattr(TerminalElement, self.input.token_type())

        if self.input.current_token != token:
            print(f'Invalid token: {token} is not {self.input.current_token}.')
            sys.exit(1)

        if self.input.token_type() == TokenType.STRING_CONST:
            token = token.strip('"')
        elif token == '<':
            token = '&lt;'
        elif token == '>':
            token = '&gt;'
        elif token == '&':
            token = '&amp;'

        if token_type == TerminalElement.IDENTIFIER:
            self.output.write('<identifier>\n')
            self.output.write(f'<name> {token} </name>\n')

            if identifier_category in ('class', 'subroutine'):
                self.output.write(f'<category> {identifier_category} </category>\n')
            else:
                # check which symbol table contains the variable
                if self.symbol_tables['subroutine'].index_of(token) >= 0:
                    level = 'subroutine'
                elif self.symbol_tables['class'].index_of(token) >= 0:
                    level = 'class'
                else:
                    level = None

                if level:
                    kind = self.symbol_tables[level].kind_of(token).name.lower()
                    self.output.write(f'<category> {kind} </category>\n')
                    self.output.write(
                        f'<index> {self.symbol_tables[level].index_of(token)} </index>\n'
                    )

            self.output.write(f'<usage> {"declared" if declaration else "used" } </usage>\n')
            self.output.write('</identifier>\n')
        else:
            self.output.write(f'<{token_type}> {token} </{token_type}>\n')

        self.input.advance()

    def compile_class(self):
        """Compile a complete class"""
        self._eat('class')
        self.classname = self.input.current_token
        self._eat(self.input.current_token)  # className
        self._eat('{')

        while self.input.current_token in ('static', 'field'):
            self.compile_class_var_dec()
        while self.input.current_token in ('constructor', 'function', 'method'):
            self.compile_subroutine()

        self._eat('}')

    def compile_class_var_dec(self):
        """Compile a static or field variable declaration"""
        var_props = {}  # data for populating the symbol table

        # variable kind
        if self.input.current_token == 'static':
            var_props[SymbolTableField.KIND] = VariableKind.STATIC
        else:
            var_props[SymbolTableField.KIND] = VariableKind.FIELD
        self._eat(self.input.current_token)  # 'static'|'field'

        # variable type
        var_props[SymbolTableField.TYPE] = self.input.current_token
        self._eat(self.input.current_token)  # type

        # variable name
        self.symbol_tables["class"].define(
            self.input.current_token,
            var_props[SymbolTableField.TYPE],
            var_props[SymbolTableField.KIND]
        )  # populate symbol table
        self._eat(self.input.current_token)  # varName

        # if a comma is present, that means there are more variables
        while self.input.current_token == ',':
            self._eat(',')
            self.symbol_tables["class"].define(
                self.input.current_token,
                var_props[SymbolTableField.TYPE],
                var_props[SymbolTableField.KIND]
            )  # populate symbol table
            self._eat(self.input.current_token)  # varName

        self._eat(';')

    def compile_subroutine(self):
        """Compile a complete method, function, or constructor"""
        # reset subroutine level symbol table
        self.symbol_tables['subroutine'].reset()
        # reset number of local variables
        self.subroutine_num_vars = 0

        self.subroutine_type = self.input.current_token
        self._eat(self.input.current_token)  # 'constructor'|'function'|'method'
        self._eat(self.input.current_token)  # 'void'|type
        self.subroutine = f'{self.classname}.{self.input.current_token}'
        self._eat(self.input.current_token)  # subroutineName
        self._eat('(')

        # if compiling a method, add 'this' reference to symbol table
        if self.subroutine_type == 'method':
            self.symbol_tables['subroutine'].define(
                'this',
                self.classname,
                VariableKind.ARG
            )

        self.compile_parameter_list()
        self._eat(')')
        self.compile_subroutine_body()

    def compile_parameter_list(self):
        """Compile a (possibly empty) parameter list"""
        if self.input.current_token != ')':
            arg_type = self.input.current_token
            self._eat(self.input.current_token)  # type
            self.symbol_tables['subroutine'].define(
                self.input.current_token,
                arg_type,
                VariableKind.ARG
            )  # populate symbol table
            self._eat(self.input.current_token, declaration=True)  # varName

            # the presence of a comma means that there are more parameters
            while self.input.current_token == ',':
                self._eat(',')
                arg_type = self.input.current_token
                self._eat(self.input.current_token)  # type
                self.symbol_tables['subroutine'].define(
                    self.input.current_token,
                    arg_type,
                    VariableKind.ARG
                )  # populate symbol table
                self._eat(self.input.current_token, declaration=True)  # varName

    def compile_subroutine_body(self):
        """Compile a subroutine's body"""
        self._eat('{')
        while self.input.current_token == 'var':
            self.compile_var_dec()

        # generate function command after variable declarations are compiled
        self.output.write_function(self.subroutine, self.subroutine_num_vars)

        # generate object instantiation code if the subroutine is a constructor
        if self.subroutine_type == 'constructor':
            # get number of field variables in class to determine object size
            num_field_vars = self.symbol_tables['class'].var_count(VariableKind.FIELD)
            # allocate memory block of required size for the object
            self.output.write_push(Segment.CONSTANT, num_field_vars)
            self.output.write_call('Memory.alloc', 1)
            # set THIS to point to the base address of the newly allocated memory block
            self.output.write_pop(Segment.POINTER, 0)
        # if subroutine is a method, generate code to map the target object to 'this' segment
        elif self.subroutine_type == 'method':
            self.output.write_push(Segment.ARGUMENT, 0)
            self.output.write_pop(Segment.POINTER, 0)

        self.compile_statements()
        self._eat('}')

    def compile_var_dec(self):
        """Compile a variable declaration"""
        self._eat('var')
        var_type = self.input.current_token
        self._eat(self.input.current_token)  # type
        self.symbol_tables['subroutine'].define(
            self.input.current_token,
            var_type,
            VariableKind.VAR
        )  # populate symbol table
        self.subroutine_num_vars += 1  # increment local variable counter
        self._eat(self.input.current_token, declaration=True)  # varName

        # check for and compile more variable names
        while self.input.current_token == ',':
            self._eat(',')
            self.symbol_tables['subroutine'].define(
                self.input.current_token,
                var_type,
                VariableKind.VAR
            )  # populate symbol table
            self.subroutine_num_vars += 1  # increment local variable counter
            self._eat(self.input.current_token, declaration=True)  # varName

        self._eat(';')

    def compile_statements(self):
        """Compile a sequence of statements"""
        # self.output.write('<statements>\n')

        while self.input.current_token != '}':
            if self.input.current_token == 'let':
                self.compile_let()
            elif self.input.current_token == 'if':
                self.compile_if()
            elif self.input.current_token == 'while':
                self.compile_while()
            elif self.input.current_token == 'do':
                self.compile_do()
            elif self.input.current_token == 'return':
                self.compile_return()

        # self.output.write('</statements>\n')

    def compile_let(self):
        """Compile a let statement"""
        self._eat('let')
        variable = self.input.current_token
        self._eat(self.input.current_token)  # varName

        # get VM memory segment and index of the variable from symbol table
        table = self._symbol_table_lookup(variable)
        segment = self._determine_var_segment(self.symbol_tables[table].kind_of(variable))
        index = self.symbol_tables[table].index_of(variable)

        # check if array element assignment or variable assignment
        if self.input.current_token == '[':  # varName'['expression']'
            self._eat('[')
            self.output.write_push(segment, index)  # base address of array
            self.compile_expression()  # index value
            self.output.write_arithmetic(ArithmeticCommand.ADD)  # target address
            self._eat(']')
            self._eat('=')
            self.compile_expression()
            self.output.write_pop(Segment.TEMP, 0)  # backup expression value
            self.output.write_pop(Segment.POINTER, 1)  # align target address with 'THAT' segment
            self.output.write_push(Segment.TEMP, 0)
            self.output.write_pop(Segment.THAT, 0)  # assign expression value to target address
        else:  # variable assignment
            self._eat('=')
            self.compile_expression()
            self.output.write_pop(segment, index)

        self._eat(';')

    def compile_if(self):
        """Compile an if statement, possibly with a trailing else clause"""
        self._eat('if')
        self._eat('(')
        self.compile_expression()
        self.output.write_arithmetic(ArithmeticCommand.NOT)
        label_1 = self._generate_label()
        self.output.write_if(label_1)
        self._eat(')')
        self._eat('{')
        self.compile_statements()
        self._eat('}')

        # handle optional else clause
        if self.input.current_token == 'else':
            self._eat('else')
            self._eat('{')
            label_2 = self._generate_label()
            self.output.write_goto(label_2)
            self.output.write_label(label_1)
            self.compile_statements()
            self.output.write_label(label_2)
            self._eat('}')
        else:
            self.output.write_label(label_1)

    def compile_while(self):
        """Compile a while statement"""
        self._eat('while')
        self._eat('(')
        label_1 = self._generate_label()
        label_2 = self._generate_label()
        self.output.write_label(label_1)
        self.compile_expression()
        self.output.write_arithmetic(ArithmeticCommand.NOT)
        self.output.write_if(label_2)
        self._eat(')')
        self._eat('{')
        self.compile_statements()
        self.output.write_goto(label_1)
        self.output.write_label(label_2)
        self._eat('}')

    def compile_do(self):
        """Compile a do statement"""
        self._eat('do')
        self._compile_subroutine_call()
        # discard return value of void subroutine
        self.output.write_pop(Segment.TEMP, 0)
        self._eat(';')

    def compile_return(self):
        """Compile a return statement"""
        self._eat('return')
        if self.input.current_token != ';':
            self.compile_expression()
        else:
            self.output.write_push(Segment.CONSTANT, 0)
        self.output.write_return()
        self._eat(';')

    def compile_expression(self):
        """Compile an expression"""
        self.compile_term()  # term

        # (op term)
        while self.input.current_token in ('+', '-', '*', '/', '&', '|', '<', '>', '='):
            op = self.input.current_token  # remember operation to be performed postfix
            self._eat(self.input.current_token)
            self.compile_term()

            if op == '+':
                self.output.write_arithmetic(ArithmeticCommand.ADD)
            elif op == '-':
                self.output.write_arithmetic(ArithmeticCommand.SUB)
            elif op == '*':
                self.output.write_call('Math.multiply', 2)
            elif op == '/':
                self.output.write_call('Math.divide', 2)
            elif op == '&':
                self.output.write_arithmetic(ArithmeticCommand.AND)
            elif op == '|':
                self.output.write_arithmetic(ArithmeticCommand.OR)
            elif op == '<':
                self.output.write_arithmetic(ArithmeticCommand.LT)
            elif op == '>':
                self.output.write_arithmetic(ArithmeticCommand.GT)
            elif op == '=':
                self.output.write_arithmetic(ArithmeticCommand.EQ)

    def compile_term(self):
        """Compile a term"""
        # (unaryOp term)
        if self.input.current_token in ('-', '~'):
            if self.input.current_token == '-':
                op = ArithmeticCommand.NEG
            else:
                op = ArithmeticCommand.NOT
            self._eat(self.input.current_token)
            self.compile_term()
            self.output.write_arithmetic(op)

        # '('expression')'
        elif self.input.current_token == '(':
            self._eat('(')
            self.compile_expression()
            self._eat(')')

        # integerConstant|stringConstant|keywordConstant|varName
        else:
            term = self.input.current_token  # save term for later use
            self._eat(self.input.current_token)

            if term.isdecimal():  # integerConstant
                self.output.write_push(Segment.CONSTANT, term)

            elif term.startswith('"'):  # stringConstant
                # pass string length as an argument to String constructor
                str_without_quotes = term[1:-1]
                self.output.write_push(Segment.CONSTANT, len(str_without_quotes))
                self.output.write_call('String.new', 1)
                for char in str_without_quotes:  # initialize String with each character
                    self.output.write_push(Segment.CONSTANT, ord(char))
                    self.output.write_call('String.appendChar', 2)

            elif keywords.get(term):  # keywordConstant
                if term in ('false', 'null'):
                    self.output.write_push(Segment.CONSTANT, 0)
                elif term == 'true':
                    self.output.write_push(Segment.CONSTANT, 1)
                    self.output.write_arithmetic(ArithmeticCommand.NEG)
                elif term == 'this':
                    self.output.write_push(Segment.POINTER, 0)

            elif table:= self._symbol_table_lookup(term):  # varName
                segment = self._determine_var_segment(self.symbol_tables[table].kind_of(term))
                index = self.symbol_tables[table].index_of(term)
                self.output.write_push(segment, index)

                if self.input.current_token == '[':  # varName'['expression']'
                    self._eat('[')
                    self.compile_expression()  # index value
                    self.output.write_arithmetic(ArithmeticCommand.ADD)  # get target address
                    # align target address with 'THAT' segment
                    self.output.write_pop(Segment.POINTER, 1)
                    self.output.write_push(Segment.THAT, 0)  # get value of array element
                    self._eat(']')

                if self.input.current_token == '.':  # subroutine (method on varName object)
                    self._eat('.')
                    self._compile_subroutine_call(call_on=term)

            elif self.input.current_token == '(':  # subroutineCall (method on current object)
                self._compile_subroutine_call(call_on=None, override_name=term)

            elif self.input.current_token == '.':  # subroutineCall (function)
                self._eat('.')
                self._compile_subroutine_call(call_on=term)

    def compile_expression_list(self):
        """Compile an (possibly empty) comma-separated list of expressions.
        Return the number of expressions in the list.
        """
        num_args = 0

        if self.input.current_token != ')':
            self.compile_expression()
            num_args += 1
        while self.input.current_token == ',':
            self._eat(',')
            self.compile_expression()
            num_args += 1

        return num_args

    def _compile_subroutine_call(self, call_on=None, override_name=None):
        """Compile a subroutine call"""
        num_args = 0

        # save subroutine name
        if not override_name:
            subroutine_name = (call_on + '.' if call_on else '') + self.input.current_token
            self._eat(self.input.current_token)
        else:
            subroutine_name = override_name

        if self.input.current_token == '.':
            self._eat('.')
            subroutine_name += f'.{self.input.current_token}'
            self._eat(self.input.current_token)  # varName

        if self.input.current_token == '(':
            self._eat('(')

            # if calling a method, pass the target object as the first argument
            if '.' in subroutine_name:  # check for varName.methodName possiblity
                var_name = subroutine_name.split('.')[0]
                
                # check if varName is in a symbol table, and thus, an object,
                # which indicates a method call. If not, it is a function call
                if table:= self._symbol_table_lookup(var_name):
                    segment = self._determine_var_segment(self.symbol_tables[table].kind_of(var_name))
                    index = self.symbol_tables[table].index_of(var_name)
                    
                    # pass the target object as the first argument
                    self.output.write_push(segment, index)
                    num_args = 1  # set argument count for method call to 1
                    
                    # replace varName with className of object
                    var_type = self.symbol_tables[table].type_of(var_name)
                    subroutine_name = f'{var_type}.{subroutine_name.split(".")[1]}'
            
            else:  # indicates a method call on the current object
                # pass 'this' (current object) as the first argument
                self.output.write_push(Segment.POINTER, 0)
                num_args = 1  # set argument count for method call to 1
                # prepend className to method call
                subroutine_name = f'{self.classname}.{subroutine_name}'

            num_args += self.compile_expression_list()
            self._eat(')')

        self.output.write_call(subroutine_name, num_args)

    def _symbol_table_lookup(self, variable):
        """Return which symbol table (subroutine, class) contains the specified variable.
        Return None if neither does.
        """
        if self.symbol_tables['subroutine'].index_of(variable) >= 0:
            return 'subroutine'
        elif self.symbol_tables['class'].index_of(variable) >= 0:
            return 'class'
        else:
            return None

    def _determine_var_segment(self, kind):
        """Return VM segment that the variable kind corresponds to"""
        if kind == VariableKind.STATIC:
            return Segment.STATIC
        if kind == VariableKind.FIELD:
            return Segment.THIS
        if kind == VariableKind.ARG:
            return Segment.ARGUMENT
        if kind == VariableKind.VAR:
            return Segment.LOCAL

    def _generate_label(self):
        self.label_count += 1
        return f'L{self.label_count}'
